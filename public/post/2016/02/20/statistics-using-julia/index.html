<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Statistics using Julia | Lanfeng Pan&#39;s Random Walk</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Statistics using Julia</span></h1>

<h2 class="date">2016/02/20</h2>
</div>

<main>


<p>Although still in alpha stage, Julia is already quite usable. It does not have so many packages as R yet but the basic recipes, such as distributions and optimization, are ready. This is enough for research usage because most of time the existing packages does not fit into the purpose. We need to reimplement our own methods any way.</p>

<p>In this post I will introduce some packages and features essential for statistical research.</p>

<h2 id="distributions">Distributions</h2>

<p>The <code>Distributions</code> is an excellent package providing quite amount of typical distributions. Distributions are of type <code>Distribution</code>. There are common interface to <code>Distribution</code>, such as <code>pdf</code>, <code>logpdf</code>, <code>cdf</code>, <code>loglikelihood</code>, <code>entropy</code> and <code>quantile</code>&hellip; For example the following code generates $$1000$$ random number from Gaussian mixture model and calculate the log-likelihood.</p>

<pre><code class="language-julia">using Distributions
m = MixtureModel(Normal, [(-2.0, 1.2),
    (0.0, 1.0), (3.0, 2.5)], [0.2, 0.5, 0.3])
x = rand(m, 1000)
loglikelihood(m, x)
</code></pre>

<p>The density functions of <code>Distributions</code> are imported from another package <code>StatsFuns</code> which use the <code>Rmath</code> library. A problem with <code>Rmath</code> is it only provide scalar density function which can be inefficient when we are evaluating on a vector of values. For example, to obtain the log-likelihood a Beta distribution on $$10000$$ data points the Beta function will be calculated for $$10000$$ times. When I was developing the <code>KernelEstimator</code> package, I realized writing the kernel function in pure Julia can be more efficient than using <code>Rmath</code>. In addition, it is possible to optimize the <code>exp</code> and <code>log</code> in vector case using <code>Yeppp</code> package. Hope one day the density functions in <code>StatsFuns</code> be rewritten in julia instead of importing <code>Rmath</code>.</p>

<h2 id="plotting">Plotting</h2>

<p>There is no very handy plotting package in Julia right now. The <code>Gadfly</code> is ambitious but the fact is its lengthy grammar, slow plotting and unsatisfactory graph for displaying in formal situations. <code>PyPlot</code> is flexible but I am not familiar with its usage. Most of the time I send the data to R via <code>RCall</code> and use the <code>plot</code> from <code>base</code> or <code>ggplot2</code>. For example</p>

<pre><code class="language-julia">using Distributions, RCall
m = MixtureModel(Normal, [(-2.0, 1.2),
    (0.0, 1.0), (3.0, 2.5)], [0.2, 0.5, 0.3])
xs = linspace(-5,6, 500)
den = pdf(m, xs)
@rput xs, den
rprint(&quot;&quot;&quot;
plot(xs, den, type=&quot;l&quot;)
&quot;&quot;&quot;)
</code></pre>

<p><code>RCall</code> is definitely more than just plotting. It can start an R session, sending data from julia to R via <code>@rput</code> and fetching from R via <code>@rget</code>. That allow us to call the large amount of available R packages within julia.</p>

<h2 id="parallel-computing">Parallel Computing</h2>

<p>Julia has its own parallel computing framework. Starting Julia with</p>

<pre><code class="language-bash">$ julia -p 4
</code></pre>

<p>will attach 4 workers if a computer has more than 4 processes. Then we can do parallel computing via the <code>pmap</code> function or the <code>@parallel</code> macro. For example, in <code>GaussianMixtureTest</code> I want to find out the largest log-likelihood among several possible $$\tau$$ values</p>

<pre><code class="language-julia">using Distributions
import GaussianMixtureTest
@everywhere using GaussianMixtureTest
x = rand(Normal(), 1000)
vtau = [.5, .3, .1;]
@parallel (max) for i in 1:3
    re=gmm(x, 2, tau = vtau[i], taufixed=true)
    re[4]
end
</code></pre>

<h2 id="parallel-on-linux-cluster">Parallel on Linux Cluster</h2>

<p>Parallel computing within a single computer can only use a few processes. But a typical simulation study may have to be repeated for thousands times while each simulation may take several hours. In this case several hundred processes are needed. It is possible for julia to combine workers or processes across many nodes. For example in a PBS system, we can start julia with 160 workers in the following way. First request 10 nodes and 16 processes on each,</p>

<pre><code class="language-bash">$ qsub -I -l nodes=10:ppn=16
</code></pre>

<p>Then start julia with</p>

<pre><code class="language-bash">$ julia --machinefile=$PBS_NODEFILE
</code></pre>

<p>This will attach all requested processes into julia. The amazing thing is the 160 processes appear no difference with the 4 local processes started by <code>julia -p 4</code> in a single computer to the user. Or in other words it can run in parallel across several computers without using MPI and thus code running locally will run on linux serve without any change.</p>

<p>Here is an example of repeating a hypothesis test for 160 times and see its asymptotic distribution. The following code first defines a function to do the simulation and uses <code>pmap</code> to run it on all workers.</p>

<p>~~~ julia
import GaussianMixtureTest, Distributions
@everywhere using GaussianMixtureTest, Distributions
@everywhere function brun(b::Int)
    srand(b)
    mu_true = [-2.0858,-1.4879]
    wi_true = [0.0828,0.9172]
    sigmas_true = [0.6735,0.2931]
    n = 282
    m = MixtureModel(map((u, v) -&gt; Normal(u, v),
     mu_true, sigmas_true), wi_true)
    x = rand(m, n)
    T1, P = GaussianMixtureTest.kstest(x, 2)
    T1
end
Tvec = pmap(brun, 1:160)
~~~~~</p>

<h2 id="more">More</h2>

<p>There are some other useful packages, such as numerical optimization packages <code>Optim</code> or <code>NLopt</code>, numerical integration package <code>Cubature</code>, Gauss Quadrature calculation package <code>FastGaussQuadrature</code> and Nonparametric estimation <code>KernelDensity</code> and <code>KernelEstimator</code>.</p>

<p>Given all these useful packages and julia&rsquo;s amazing speed, everyone who want to develop some statistical method from scratch should have a try in julia.</p>

</main>

  <footer>
  <script src="//yihui.name/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>

  
  <hr/>
  &copy; <a href="https://lanfeng.me">Lanfeng Pan</a> | <a href="https://github.com/panlanfeng">Github</a>
  
  </footer>
  </body>
</html>

